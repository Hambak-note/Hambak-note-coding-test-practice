# BOJ 2579번: 계단 오르기

<br>
<br>

## 문제 풀이 방식

<br>

### 1. 테이블 정의하기
- D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단은 반디스 밟아야 함
- 2차원 배열이 된 이유는 지금까지 몇 개의 계단을 밟았느지에 대한 정보가 추가로 있어야 점화식을 세울 때 계단을 오르는 규칙을 고려할 수 있기 때문
- 단 i 번째 계단을 밟아야 함 이라는 조건이 있어야 점화식을 이끌어 낼 수 있다.
- 위의 2차원 배열에서 j는 어떤 값을 가지는지 보면 i번째 계단을 반드시 밟아야 한다는 조건이 있기 때문에  j=1 혹은 2이다. 
- 연속된 세 개의 계단을 모두 밟아서는 안된다는 조건으로 인해 j가 3 이상일 수는 없다.
 
<br>

### 2. 점화식 찾기
- D[k][1]?
  - 현재까지 1개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때 점수 합의 최대값
  - 현재까지 1개의 계단을 연속해서 밟았다는 의미는 곧 k-1번째 계단을 밟지 않았다는 의미
  - 그렇다면 계단을 한 계단씩 또는 두 계단씩 오를 수 있다고 했기 때문에 k-2번째 계단을 밟았다는 건 너무나 확실
  - k-2번째 계단을 밟았을 때 얻은 점수의 최댓값은 D[k-2][1] 혹은 D[k-2][2]에 저장되어 있을 것이다.
  - 최종적으로 D[k-2][1] 혹은 D[k-2][2]에 잘 저장되어 있을 것이다.
  - D[k][1] = max(D[k-2][1], D[k-2][2]) + S[k]
  - S[k]는 k번째 계단에 쓰여 있는 점수를 의미
- D[k][2]?
  - 현재까지 2개의 계단을 연속해서 밟고 k번째 계단까지 올라섰을 때 점수 합의 최댓값.
  - 현재까지 2개의 계단을 연속해서 밟았으니 k-1번째 계단을 밟았다는 건 알 수 있는데, 추가적인 조건 1개가 더 있어야 한다.
  - k-1번째 계단을 밟을 당시에는 1개의 계단을 연속해서 밟은 상태여야 한다.
  - 만약 k-1번째 계단을 밟을 당시에 2개의 계단을 연속해서 밟은 상태였다면 연속한 세 개의 계단을 모두 밟아서는 안된다는 조건으로 인해 k번째 계단을 밟는게 불가능하다.
  - 때문에 D[k][2] = d[k-1][1] + S[k]가 된다.
- 이렇게 얻어낸 식을 가지고 테이블을 채운 뒤에 마지막 도착 계단은 반드시 밟아야 한다는 조건을 고려해 max(D[N][1], D[N][2])를 출력하면 끝
  - 즉 N번째 계단을 올라서기 전에 1개의 계단을 연속해서 밟고 있는 상태이거나 2계의 계단을 연속해서 밟고 있는 상태인 경우에서의 최대 값을 출력하는 것이다.

<br>

### 3. 초기값 정의하기
- D[k][1]을 구할 때 D[k-2][1], D[k-2][2] 테이블을 참고한다.
- D[1][1] = S[1], D[1][2] = 0
  - 현재 1개의 계단을 연속해서 밟고 1번째 계단까지 올랐을 때 최대값은 S[1]
  - 현재까지 2개의 계단을 연속해서 밟고 1번째 계단까지 오를 수 없으므로 0
- D[2][1] = S[2]
  - 현재 1개의 계단을 연속해서 밟고 2번째 계단까지 올랐을 때 최대값
- D[2][2] = S[1] + S[2]
  - 현재 2개의 계단을 연속해서 밟고 2번째 계단까지 올랐을 때 최대값
  

<br>

### 4. 로직 구현

```java
     if(numberOfSteps==1){
            System.out.println(valuesOfSteps[1]);
            return;
        }

        dp[1][1] = valuesOfSteps[1];
        dp[1][2] = 0;
        dp[2][1] = valuesOfSteps[2];
        dp[2][2] = valuesOfSteps[1] + valuesOfSteps[2];

        for(int i = 3; i <= numberOfSteps; i++){
            dp[i][1] = Math.max(dp[i-2][1], dp[i-2][2])+valuesOfSteps[i];
            dp[i][2] = dp[i-1][1] + valuesOfSteps[i];
        }

        System.out.println(Math.max(dp[numberOfSteps][1], dp[numberOfSteps][2]));
```

<br>
<br>

## links
---
### 출처
- https://www.youtube.com/watch?v=5leTtB3PQu0&t=58s&ab_channel=BaaarkingDog

<br>

### 전체 소스코드
- https://github.com/Hambak-note/coding-test-practice/blob/main/codes/src/baekjoon/dp/BOJ_2579.java